(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[136],{30749:(e,i,t)=>{"use strict";e.exports=t.p+"images/pinAnchor.png"},56241:(e,i,t)=>{"use strict";t.d(i,{y:()=>DisableCursorMeshCommand});var n=t(17386);class DisableCursorMeshCommand extends n.m{constructor(e){super(),this.payload={disable:e}}}},67394:(e,i,t)=>{"use strict";t.r(i),t.d(i,{default:()=>CursorController});var n=t(47724),s=t(68113),a=t(5087),r=t(35597),o=t(69941),d=t(19047),h=t(75892),c=t(56241),l=t(33874),p=t(55461),u=t(69927),m=t(63781);class CursorController extends n.Y{constructor(){super(...arguments),this.name="cursor-controller",this.visibilityRules=[],this.disabled=!1}async init(e,i){[this.cursorMesh,this.cursorData]=await Promise.all([i.getModule(s.default),i.market.waitForData(u.Y)]),this.visibilityRules.push((()=>{const e=i.market.tryGetData(r.O);return!!e&&(0,a.Bw)(e.closestMode)}),(()=>{const e=i.market.tryGetData(h.Z);return!!e&&!e.isSweepUnaligned(e.currentSweep)}),(()=>{const e=i.market.tryGetData(o.k);return!!e&&!e.isTourActive()}),(()=>{const e=i.market.tryGetData(d.Z);return!!e&&!e.isMobile()}),(()=>{const e=i.market.tryGetData(l.e);return!!e&&e.tryGetProperty(p.b,!0)})),this.bindings.push(i.commandBinder.addBinding(c.y,(async e=>{this.disabled=e.disable})))}onUpdate(){this.updateCursorVisibility()}addVisibilityRule(e){this.visibilityRules.push(e)}removeVisibilityRule(e){const i=this.visibilityRules.indexOf(e);-1!==i&&this.visibilityRules.splice(i,1)}setFadeProps(e){const{fadeOut:i,fadeIn:t}=e;m.default.fadeOutDuration=i&&i.duration?i.duration:m.default.fadeOutDuration,m.default.fadeOutDelay=i&&i.delay?i.delay:m.default.fadeOutDelay,m.default.fadeInDuration=t&&t.duration?t.duration:m.default.fadeInDuration}updateCursorVisibility(){const e=!this.disabled&&this.visibilityRules.reduce(((e,i)=>e&&i()),!0);this.cursorMesh.setVisible(e)}setTexture(e){this.cursorData.texture=e}}},59167:(e,i,t)=>{"use strict";t.d(i,{n:()=>MeshPreviewSetPositonCommand});var n=t(17386);class MeshPreviewSetPositonCommand extends n.m{constructor(e,i,t){super(),this.id="MESH_PREVIEW_POSITION",this.payload={enabled:e,previewCirclePosition:i,size:t}}}},61709:(e,i,t)=>{"use strict";t.d(i,{z:()=>InstancedPinHeads});var n=t(48358),s=t(88512),a=t(2212),r=t(4299),o=t(79386);const d=new s.Z("InstancedPinHeads");class InstancedPinHeads extends a.InstancedMesh{constructor(e,i,t,s){const d=new a.PlaneBufferGeometry(o.l,o.l),h=new Float32Array(e),c=new a.InstancedBufferAttribute(h,1);d.setAttribute("instanceAlpha",c);super(d,s&&t?new r.Vp(i,t):new r.m0(i,!0),e),this.maxCount=e,this.opacityArray=h,this.opacityAttrib=c,this.setColorAt(0,new a.Color),this.renderedPins=[],this.renderOrder=n.z.pins}update(e){let i=0;this.renderedPins.length=0;for(const t of e)t.visible&&(i>=this.maxCount?d.error("Instance count is too small!"):(this.setMatrixAt(i,t.pinHeadMatrix),this.setColorAt(i,t.pinColor),this.opacityArray[i]=t.opacity*t.opacityAnimation.value,i++,this.renderedPins.push(t)));this.count=i,this.visible=this.count>0,this.instanceMatrix.needsUpdate=!0,this.opacityAttrib.needsUpdate=!0,this.instanceColor?this.instanceColor.needsUpdate=!0:d.error("Instance color should be defined")}}},40554:(e,i,t)=>{"use strict";t.d(i,{$:()=>PinHeadMesh});var n=t(68524),s=t(48358),a=t(2212),r=t(49487),o=t(27408),d=t(79386);class PinHeadMesh extends a.Mesh{constructor(e,i,t,n){super(i,t),this.geomScale=new a.Vector3(1,1,1),this.userData.sid=e,this.worldPosition=new a.Vector3,this.cameraPosition=new a.Vector3,this.layers.mask=n.mask,this.renderOrder=s.z.pins,this.scale.set(.01,.01,.01)}dispose(){this.material.dispose(),this.geometry.dispose()}updatePosition(e){this.position.copy(e.stemNormal).setLength(Math.max(e.stemLength,.01))}update(e,i,t){const s=d.Z.pinHeadMesh.scale;this.getWorldPosition(this.worldPosition);const h=e.getWorldPosition(this.cameraPosition).distanceTo(this.worldPosition);this.quaternion.copy(e.quaternion);const c=s.maxSize-(s.maxSize-s.minSize)*(0,r.C)(h,s.nearBound,s.farBound),l=this.worldPosition.clone().project(e),p=new a.Vector3(t.width/2,t.height/2,1).multiply(l),u=new a.Vector3(c/2,0,0).add(p),m=new a.Vector3(2/t.width,2/t.height,1).multiply(u).clone().unproject(e).clone().distanceTo(this.worldPosition)*(1+s.responsiveness/100*(i-1)),P=(0,o.uZ)(m,n.Z.epsilon,m);this.scale.set(P*this.geomScale.x,P*this.geomScale.y,P*this.geomScale.z)}}},4299:(e,i,t)=>{"use strict";t.d(i,{Vp:()=>InstancedPinHeadMaterial,uW:()=>InstancedPinStemMaterial,m0:()=>PinHeadCustomMaterial,Nv:()=>PinHeadMaterial,Dx:()=>PinSelectedMaterial,l0:()=>PinStemMaterial});var n=t(2212),s=t(79386);const a={pinHead:{uniforms:{alpha:{type:"f",value:1},color:{type:"c",value:new n.Color},bg:{type:"t",value:null},mask:{type:"t",value:null}},vertexShader:t(34086),fragmentShader:t(36888)},pinStem:{uniforms:{pinHeadMatrix:{value:new n.Matrix4},resolution:{value:new n.Vector2},alpha:{value:1}},vertexShader:t(18934),fragmentShader:t(7532)},pinSelected:{vertexShader:t(18144),fragmentShader:t(81713)}};class PinHeadMaterial extends n.RawShaderMaterial{constructor(e,i,t,s){const r=n.UniformsUtils.clone(a.pinHead.uniforms);r.bg.value=i,r.mask.value=t,r.color.value.copy(e),r.alpha.value=s,super({fragmentShader:a.pinHead.fragmentShader,vertexShader:a.pinHead.vertexShader,uniforms:r,name:"PinHeadMaterial",transparent:!0})}}class PinStemMaterial extends n.RawShaderMaterial{constructor(){const e=n.UniformsUtils.clone(a.pinStem.uniforms);super({fragmentShader:a.pinStem.fragmentShader,vertexShader:a.pinStem.vertexShader,uniforms:e,name:"PinStemMaterial",linewidth:s.Z.stem.width,opacity:s.Z.stem.opacity,transparent:s.Z.stem.transparent,alphaTest:s.Z.stem.opacity*s.Z.stem.alphaTest})}}class InstancedPinStemMaterial extends n.RawShaderMaterial{constructor(){const e=n.UniformsUtils.clone(a.pinStem.uniforms);super({defines:{INSTANCED:!0},fragmentShader:a.pinStem.fragmentShader,vertexShader:a.pinStem.vertexShader,uniforms:e,name:"InstancedPinStemMaterial",linewidth:s.Z.stem.width,opacity:s.Z.stem.opacity,transparent:s.Z.stem.transparent,alphaTest:s.Z.stem.opacity*s.Z.stem.alphaTest})}}class InstancedPinHeadMaterial extends n.RawShaderMaterial{constructor(e,i){const t=n.UniformsUtils.clone(a.pinHead.uniforms);t.bg.value=e,t.mask.value=i,super({defines:{INSTANCED:!0},fragmentShader:a.pinHead.fragmentShader,vertexShader:a.pinHead.vertexShader,uniforms:t,name:"InstancedPinHeadMaterial",transparent:!0})}}class PinHeadCustomMaterial extends n.RawShaderMaterial{constructor(e,i){super({defines:{INSTANCED:i},vertexShader:t(79826),fragmentShader:t(64715),uniforms:{alpha:{value:1},tDiffuse:{value:e}},name:"InstancedPinHeadCustomMaterial",transparent:!0})}}class PinSelectedMaterial extends n.RawShaderMaterial{constructor(){super({depthTest:!0,depthWrite:!1,transparent:!0,side:n.DoubleSide,vertexShader:a.pinSelected.vertexShader,fragmentShader:a.pinSelected.fragmentShader})}}},41591:(e,i,t)=>{"use strict";t.r(i),t.d(i,{CancelNewPinCommand:()=>_.tT,ChangePinOpacityByTypeCommand:()=>_.kb,ChangePinOpacityCommand:()=>_._Y,ChangePinVisibilityByTypeCommand:()=>_.qN,ChangePinVisibilityCommand:()=>_.ik,ClickOffPinCommand:()=>_.yR,CreatePinCommand:()=>_.fM,EnablePinCreationCommand:()=>_.Ki,MovePinCommand:()=>_.I$,NewPinReadyMessage:()=>Z.cd,PinAddCancelledMessage:()=>Z.hu,PinAnchorMesh:()=>PinAnchorMesh,PinClickedMessage:()=>Z.F7,PinColorVariant:()=>F.K_,PinEditor:()=>PinEditor,PinEditorState:()=>F.V8,PinHeadMesh:()=>U.$,PinHoverChangeMessage:()=>Z.tP,PinMovedMessage:()=>Z.bV,PinPlacedMessage:()=>Z.b0,PinPlacementCancelledMessage:()=>Z.pe,PinPreviewDirection:()=>F.Od,PinRenderer:()=>PinRenderer,PinSelectedMessage:()=>Z.Q4,PinType:()=>F.Er,PinUnselectedMessage:()=>Z.WM,PinsViewData:()=>w.B,PlacePinCommand:()=>_.ip,RemovePinCommand:()=>_.OL,RemovePinsByTypeCommand:()=>_.zM,SelectPinCommand:()=>_.Ar,UnselectPinCommand:()=>_.RH,UpdatePinCommand:()=>_.tE,UpdatePinViewsCommand:()=>_.mE,default:()=>pe});var n=t(2212),s=t(47724),a=t(96909),r=t(27687),o=t(60771),d=t(21479),h=t(40168),c=t(27326),l=t(19047),p=t(59088),u=t(75892),m=t(35597),P=t(5087),g=t(51764),v=t(88814),y=t(35015),w=t(32025),C=t(17490),f=t(76541),M=t(37606),b=t(36123),T=t(14092);var S=t(4901),D=t(25269),x=t(88512),E=t(24764),A=t(76863),H=t(76870),V=t(49340),B=t(35003),I=t(51869),R=t(33665),k=t(88727),N=t(88216),O=t(81507),F=t(42835),U=t(40554),L=t(48358),G=t(66223),j=t(30749),z=t(79386);class PinAnchorMesh extends n.Mesh{constructor(e){super(new n.PlaneBufferGeometry(z.Z.anchor.size,z.Z.anchor.size),new n.MeshBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,map:PinAnchorMesh.getTexture(),side:n.DoubleSide})),this.visible=!1,this.layers.mask=e.mask,this.renderOrder=L.z.pins}static getTexture(){return PinAnchorMesh.anchorTexture||(PinAnchorMesh.anchorTexture=(0,G.p)(j)),PinAnchorMesh.anchorTexture}}var _=t(38321),Z=t(48470),W=t(26627),$=t(95586),K=t(29422),Y=t(59167),q=t(56241);class PinEditor{constructor(e,i,t,s){this.viewData=e,this.engine=i,this.input=t,this.pinRenderer=s,this.editEnabled=!1,this.handlersRegistered=!1,this.bindings=[],this.externalBehaviorsBlocked=!1,this.touchDevice=(0,o.Jm)(),this.longPressCreateThreshold=500,this.ndcPoint=new n.Vector3,this.movingPin=!1,this.anchored=!1,this.inAnchorClick=!1,this.log=new x.Z("pin-editor"),this.stopEventPropagation=()=>!0,this.updateMeshPreviewSphere=async(e,i)=>{this.engine.commandBinder.issueCommand(new Y.n(e,i))},this.startPinCreation=()=>{this.editEnabled&&(this.addingHandlers.renew(),this.touchDevice||this.engine.commandBinder.issueCommand(new S.u(T.C.XHAIR)),this.engine.commandBinder.issueCommand(new $.ZD))},this.endPinCreation=()=>{this.editEnabled&&(this.draggingHandlers.cancel(),this.addingHandlers.cancel(),this.clearLongPressTimeout(),this.allowExternalBehaviors(!0),this.engine.commandBinder.issueCommand(new S.u(T.C.DEFAULT)),this.engine.commandBinder.issueCommand(new $.zd))},this.onSelectedPinChanged=()=>{const{selectedPin:e}=this.viewData;e?this.selectedHandlers.renew():this.selectedHandlers.cancel(),this.updateAnchorMesh()},this.onPinStateUpdated=()=>{const e=this.viewData.pinEditorState;switch(this.updateAnchorMesh(),e){case F.V8.PLACING:this.draggingHandlers.renew();break;case F.V8.IDLE:this.allowExternalBehaviors(!0)}},this.updateAnchorMesh=()=>{if(!this.editEnabled)return;const{selectedPin:e,pinEditorState:i,isPinEditable:t}=this.viewData;e&&i!==F.V8.CREATING?([F.V8.PLACING,F.V8.PLACED].includes(i)||t?(this.pinRenderer.showAnchorMesh(e.pinType,e.id,e),this.anchored=!0):this.removePinAnchorMesh(),this.editableSelectedHandlers.renew()):(this.editableSelectedHandlers.cancel(),this.anchored&&(this.removePinAnchorMesh(),this.updateMeshPreviewSphere(!1)))},this.clearLongPressTimeout=()=>{this.longPressStart=0,-1!==this.longPressTimeout&&window.clearTimeout(this.longPressTimeout),this.longPressTimeout=-1},this.placePin=()=>{this.viewData.pinEditorState===F.V8.PLACING&&(this.engine.commandBinder.issueCommand(new S.u(T.C.DEFAULT)),this.engine.commandBinder.issueCommand(new _.ip),this.engine.broadcast(new Z.cd),this.updateMeshPreviewSphere(!1))},this.onDragEvent=e=>{e.buttons!==H.r3.PRIMARY&&(this.touchDevice||this.viewData.selectedPin)||this.positionPin(e)},this.onDragEnd=e=>{const{selectedPin:i,creatingNewPin:t,pinEditorState:n}=this.viewData;if((!t||this.touchDevice||n!==F.V8.PLACING)&&i&&!t){const e={anchorPosition:i.anchorPosition,stemNormal:i.stemNormal,floorId:i.floorId,roomId:i.roomId,stemLength:i.stemLength,stemEnabled:i.stemEnabled,color:i.color};this.engine.commandBinder.issueCommand(new _.I$(i.id,e)),this.updateMeshPreviewSphere(!1)}},this.positionPin=(()=>{const e=new n.Vector3;return async i=>{if(this.touchDevice&&i.buttons!==H.r3.PRIMARY)return!1;const t=this.viewData,n=t.pinEditorState;if(n===F.V8.CREATING)this.engine.commandBinder.issueCommand(new q.y(!0));else if(n!==F.V8.PLACING&&!this.movingPin)return!1;const s=t.selectedPin;if(!s)return!1;this.saveScreenPosition(i.position.x,i.position.y);const a=this.getModelIntersection();if(a&&a.face){this.engine.commandBinder.issueCommand(new S.u(T.C.XHAIR)),t.setCanPlace(!0);const i=((e,i,t)=>{var n;return null!==(n=i.floorIdFromObject(t.object))&&void 0!==n?n:e.getClosestFloorAtHeight(t.point.y).id})(this.floorsData,this.meshQuery,a);if(null===i)return!1;const r=this.meshQuery.mdsRoomIdFromObject(a.object);return e.copy(s.stemNormal).setLength(s.stemLength),this.updateMeshPreviewSphere(!0,s.anchorPosition),t.updateSelectedPin({anchorPosition:s.anchorPosition.copy(a.point),stemNormal:s.stemNormal.copy(a.face.normal).normalize(),floorId:i,roomId:r}),n===F.V8.CREATING&&t.setPinEditorState(F.V8.PLACING),!0}return this.engine.commandBinder.issueCommand(new S.u(T.C.NOPE)),t.setCanPlace(!1),!1}})(),this.allowExternalBehaviors=async e=>{e||this.externalBehaviorsBlocked?e&&this.externalBehaviorsBlocked&&(this.dragInterceptor.cancel(),this.engine.commandBinder.issueCommand(new K.Lp),this.externalBehaviorsBlocked=!1):(this.dragInterceptor.renew(),this.engine.commandBinder.issueCommand(new K.ZK),this.externalBehaviorsBlocked=!0)},this.getModelIntersection=()=>{const e=.5*z.Z.anchor.size;return this.fatcaster.cast(e,A.Nr,M.a.Filter.CENTER_GROUP(e))},this.onPointerButton=e=>{e.down||this.viewData.pinEditorState!==F.V8.PLACED||(this.allowExternalBehaviors(!0),this.engine.commandBinder.issueCommand(new q.y(!1)))},this.onAnchorSelect=e=>{const{selectedPin:i,isPinEditable:t,pinEditorState:n}=this.viewData;!i||e.button!==H.MP.PRIMARY||n!==F.V8.PLACED&&n!==F.V8.IDLE||(t?e.down?(this.movingPin=!0,this.allowExternalBehaviors(!1),this.draggingHandlers.renew(),this.engine.commandBinder.issueCommand(new S.u(T.C.GRABBING)),this.engine.commandBinder.issueCommand(new q.y(!0)),this.inAnchorClick=!0):(this.doneMovingPin(),this.inAnchorClick=!1):this.log.debug("onAnchorSelect called on a non-editable pin"))},this.doneMovingPin=()=>{this.viewData.selectedPin&&this.movingPin&&(this.draggingHandlers.cancel(),this.engine.commandBinder.issueCommand(new S.u(null)),this.engine.commandBinder.issueCommand(new q.y(!1)),this.movingPin=!1,this.allowExternalBehaviors(!0),this.updateMeshPreviewSphere(!1))},this.onClickElsewhere=e=>{const{selectedPin:i,pinEditorState:t}=this.viewData;if(!(t===F.V8.CREATING&&i||this.inAnchorClick))return i&&(this.movingPin?this.doneMovingPin():this.engine.commandBinder.issueCommand(new _.yR)),!0},this.onLongPressStart=async e=>{if(e.buttons!==H.r3.PRIMARY)return;const i=this.viewData;i.pinEditorState===F.V8.CREATING&&(this.longPressStart=Date.now(),i.setPinEditorState(F.V8.PRESSING),this.allowExternalBehaviors(!1),this.saveScreenPosition(e.position.x,e.position.y),this.longPressTimeout=window.setTimeout((async()=>{i.setPinEditorState(F.V8.PLACING);await this.positionPin(e)||(i.setPinEditorState(F.V8.CREATING),i.setCanPlace(!1)),this.longPressTimeout=-1}),this.longPressCreateThreshold))},this.onLongPressEnd=()=>{const e=this.viewData.pinEditorState;e===F.V8.PRESSING?(this.log.debug("Did not press long enough"),this.endPinCreation()):e===F.V8.PLACING&&this.placePin()},this.onPointerEvent=e=>{const i=this.viewData.pinEditorState;i!==F.V8.PLACING&&i!==F.V8.CREATING||this.positionPin(e)},this.onClickToPlacePin=()=>{this.placePin()},this.onKeyEvent=e=>{if(e.state===N.M.PRESSED)switch(e.key){case O.R.ESCAPE:this.viewData.creatingNewPin&&this.engine.broadcast(new Z.pe)}},Promise.all([i.market.waitForData(p.M_),i.market.waitForData(W.i),i.getModule(f.default),i.getModuleBySymbol(a.y.MESH_QUERY)]).then((([i,n,s,a])=>{this.cameraData=i,this.floorsData=n,this.fatcaster=s,this.meshQuery=a,this.bindings.push(t.registerPriorityHandler(V.er,U.$,this.stopEventPropagation),e.onSelectedPinChanged(this.onSelectedPinChanged)),this.selectedHandlers=new C.V(t.registerPriorityHandler(B.R,b.S,this.onClickElsewhere),t.registerPriorityHandler(B.R,D.i,this.onClickElsewhere)),this.selectedHandlers.cancel()}))}dispose(){this.removePinAnchorMesh(),this.updateMeshPreviewSphere(!1),this.dragInterceptor.cancel(),this.addingHandlers.cancel(),this.draggingHandlers.cancel(),this.selectedHandlers.cancel(),this.editableSelectedHandlers.cancel(),this.bindings.forEach((e=>{e.cancel()}))}update(){if(!this.editEnabled)return;const e=this.viewData;if(this.touchDevice&&e.pinEditorState===F.V8.PRESSING){const i=Math.min(1,(Date.now()-this.longPressStart)/this.longPressCreateThreshold);e.setProgress(i)}}toggleEditing(e){e!==this.editEnabled&&(this.editEnabled=e,e?(this.handlersRegistered?this.creationHandlers.renew():this.registerHandlers(),this.updateAnchorMesh()):(this.inAnchorClick=!1,this.anchored=!1,this.movingPin=!1,this.creationHandlers.cancel(),this.allowExternalBehaviors(!0),this.removePinAnchorMesh(),this.updateMeshPreviewSphere(!1)),this.dragInterceptor.cancel(),this.draggingHandlers.cancel(),this.addingHandlers.cancel(),this.editableSelectedHandlers.cancel())}registerHandlers(){const e=this.input,i=this.viewData;this.creationHandlers=new C.V(i.onPinEditorStateChanged(this.onPinStateUpdated)),this.dragInterceptor=new C.V(e.registerPriorityHandler(I._t,b.S,(()=>!0)),e.registerPriorityHandler(I._t,D.i,(()=>!0))),this.draggingHandlers=new C.V(e.registerUnfilteredHandler(I._t,this.onDragEvent),e.registerUnfilteredHandler(I._R,this.onDragEnd)),this.editableSelectedHandlers=new C.V(e.registerMeshHandler(V.er,E.s.isType(PinAnchorMesh),this.onAnchorSelect)),this.touchDevice?this.addingHandlers=new C.V(e.registerHandler(V.er,this.onPointerButton),e.registerUnfilteredHandler(R.Vh,this.onLongPressStart),e.registerUnfilteredHandler(R.pt,this.onLongPressEnd)):this.addingHandlers=new C.V(e.registerHandler(k.e,this.onKeyEvent),e.registerHandler(V.er,this.onPointerButton),e.registerUnfilteredHandler(B.R,this.onClickToPlacePin),e.registerHandler(V.mE,this.onPointerEvent))}removePinAnchorMesh(){this.pinRenderer.hideAnchorMesh(),this.anchored=!1}saveScreenPosition(e,i){this.ndcPoint.set(e,i,0);const t=(0,r.fi)(this.cameraData.width,this.cameraData.height,this.ndcPoint);this.viewData.setScreenPosition(t)}}var Q=t(94610),J=t(70179),X=t(21922),ee=t(79437),ie=t(4299);class PinSelectedMesh extends n.Mesh{constructor(e){super(new n.PlaneBufferGeometry(z.Z.anchor.size,z.Z.anchor.size),new ie.Dx),this.visible=!1,this.layers.mask=e.mask,this.renderOrder=L.z.pinSelectedHalo}}class PinRenderer{constructor(e,i,t,s){this.input=e,this.layer=i,this.commandBinder=t,this.raycaster=s,this.container=new n.Object3D,this.floorIdToContainer=new Map,this.hexColorToColor=new Map,this.bindings=[],this.anchor=null,this.selected=null,this.haloEasing=(0,ee.tf)(.5,.52,0,1.98),this.pinsWithOverrideTexture=new Set,this.updateAnchorPosition=(()=>{const e=new n.Vector3,i=new n.Vector3,t=new n.Vector3;return n=>{const s=this.anchorMesh;if(!s)return;const a=this.raycaster.picking;e.copy(n.stemNormal).normalize(),i.copy(e).multiplyScalar(.2).add(n.anchorPosition),t.copy(e).multiplyScalar(-1);const r=a.pick(i,t,(e=>e instanceof X.g));if(r){const e=Math.min(.2,r.distance);s.position.copy(i).add(t.multiplyScalar(.999*e))}else s.position.copy(i).add(t.multiplyScalar(.999*n.stemLength));s.lookAt(i)}})(),this.onAnchorHover=()=>{this.commandBinder.issueCommand(new S.u(T.C.GRAB)),this.commandBinder.issueCommand(new q.y(!0))},this.onAnchorUnhover=()=>{this.commandBinder.issueCommand(new S.u(null)),this.commandBinder.issueCommand(new q.y(!1))}}init(){this.container.name="PinContainer",this.container.layers.mask=this.layer.mask,this.anchorMesh=new PinAnchorMesh(this.layer),this.anchorMesh.name="Anchor Mesh",this.container.add(this.anchorMesh),this.selectedMesh=new PinSelectedMesh(this.layer),this.selectedMesh.name="Selected Mesh",this.container.add(this.selectedMesh)}dispose(){this.container.parent&&this.container.parent.remove(this.container);for(const e of[this.anchorMesh,this.selectedMesh])e&&e.parent&&e.parent.remove(e)}activate(e){this.bindings.length>0||this.bindings.push(this.input.registerMeshHandler(Q.z,E.s.isType(PinAnchorMesh),this.onAnchorHover),this.input.registerMeshHandler(Q.A,E.s.isType(PinAnchorMesh),this.onAnchorUnhover))}deactivate(e){for(const e of this.bindings)e.cancel();this.bindings.length=0}render(e){if(!this.selected)return;const{animation:i,hideWhenDoneAnimating:t}=this.selected,s=this.selectedMesh;if(s&&s.visible&&i){const e=this.pinHeadTransform(this.selected.id),a=new n.Vector3,r=new n.Quaternion,o=new n.Vector3;e.decompose(a,r,o),o.multiplyScalar(i.getUpdatedValue()),t&&!i.isAnimating?(s.visible=!1,this.selected=null):(s.position.copy(a),s.quaternion.copy(r),s.scale.copy(o))}}updatePin(e,i,t,n,s,a){this.anchorMesh&&this.anchorMesh.visible&&this.anchor&&this.anchor.pinType===i&&this.anchor.id===e&&this.updateAnchorPosition(t)}removePin(e){this.selected&&this.selected.id===e&&this.clearSelected()}removePinsByType(e){this.removePinsByPredicate((i=>i===e))}removePinsByPredicate(e){}setPinVisible(e,i){}setPinColorVariant(e,i){}setPinColorVariants(e,i){}setPinColorVariantByType(e,i,t){}setPinOpacity(e,i){}setPinOpacityByType(e,i,t){}fadePinOpacity(e,i){}fadePinOpacityByType(e,i,t=[]){}setPinRenderOverrides(e,i,t){i?(this.pinsWithOverrideTexture.add(e),this.selected&&this.selected.id===e&&this.clearSelected()):this.pinsWithOverrideTexture.delete(e)}setFloorsHidden(e){this.floorIdToContainer.forEach(((i,t)=>{i.visible=!e(t)}))}setPinTypeVisible(e,i){this.floorIdToContainer.forEach((t=>{t.userData.typeContainers[e].visible=i}))}showAnchorMesh(e,i,t){this.anchor={pinType:e,id:i},this.anchorMesh&&!this.anchorMesh.visible&&(this.anchorMesh.visible=!0,this.input.registerMesh(this.anchorMesh,!1)),this.updateAnchorPosition(t)}hideAnchorMesh(){this.anchorMesh&&this.anchorMesh.visible&&(this.anchorMesh.visible=!1,this.input.unregisterMesh(this.anchorMesh))}showSelectedMesh(e,i){const t=this.selected&&this.selected.pinType===e&&this.selected.id===i;this.selected&&t||this.pinsWithOverrideTexture.has(i)||(this.selected={pinType:e,id:i,hideWhenDoneAnimating:!1,animation:new J.Z({startValue:10,endValue:14,duration:300,easingFunction:this.haloEasing})},this.selectedMesh.visible=!0)}hideSelectedMesh(){this.selected&&(this.selected.animation=new J.Z({startValue:14,endValue:10,duration:300}),this.selected.hideWhenDoneAnimating=!0)}getFloorContainer(e){let i=this.floorIdToContainer.get(e);if(i)return i;i=new n.Object3D,i.name="Floor "+e,i.userData.typeContainers={},i.layers.mask=this.layer.mask;for(const e of Object.values(F.Er)){const t=new n.Object3D;t.name=e,t.layers.mask=this.layer.mask,i.add(t),i.userData.typeContainers[e]=t}return this.container.add(i),this.floorIdToContainer.set(e,i),i.userData.floorId=e,i}getColor(e){let i=this.hexColorToColor.get(e);if(i)return i;const t=new n.Color(e),s={h:0,s:0,l:0};t.getHSL(s);return i={baseColor:t,hoverColor:(new n.Color).setHSL(s.h,s.s,.8*s.l),dimmedColor:(new n.Color).setHSL(s.h,.5*s.s,s.l)},this.hexColorToColor.set(e,i),i}getViewportScale(e){return Math.sqrt(Math.min(e.width,e.height)/z.Z.pinHeadMesh.scale.baseViewportSize)}clearSelected(){this.selectedMesh.visible=!1,this.selected=null}}class PinStemMesh extends n.Line{constructor(e,i,t,s,a){const r=new n.BufferGeometry,o=new Float32Array(6);o[0]=o[1]=o[2]=0,o[3]=e.x,o[4]=e.y,o[5]=e.z,r.setAttribute("position",new n.BufferAttribute(o,3));const d=new ie.l0;super(r,d),this.geometry=r,this.layers.mask=t.mask,this.visible=i,this.vector=e.clone(),this.onBeforeRender=(e,i,t,n,r)=>{const o=r;o.uniforms.pinHeadMatrix.value.copy(s.matrixWorld),o.uniforms.resolution.value.set(a.width,a.height),o.uniformsNeedUpdate=!0},this.pinStemMaterial=d}dispose(){this.geometry.dispose()}updatePosition(e){this.vector.copy(e.stemNormal).setLength(Math.max(e.stemLength,.01));const i=this.geometry.getAttribute("position");i.setXYZ(1,this.vector.x,this.vector.y,this.vector.z),i.needsUpdate=!0}}function te(e,i){switch(i){case F.K_.DEFAULT:return e.baseColor;case F.K_.DIMMED:return e.dimmedColor;case F.K_.HIGHLIGHTED:return e.hoverColor}}var ne=t(17131);class PinMeshGroup extends n.Object3D{constructor(e,i,t,s,a,r,o,d){super(),this.pinId=e,this.pinType=i,this.pinColor=s,this.stemVector=new n.Vector3,this.stemEnabled=!0,this.currentColorVariant=F.K_.DEFAULT,this.baseOpacity=1,PinMeshGroup.pinHeadGeometry||(PinMeshGroup.pinHeadGeometry=new n.PlaneBufferGeometry(z.l,z.l));const h=(new n.Color).copy(s.baseColor);this.pinHeadMeshMaterial=new ie.Nv(h,o,d,1),this.pinHeadMesh=new U.$(e,PinMeshGroup.pinHeadGeometry,this.pinHeadMeshMaterial,a),this.add(this.pinHeadMesh),this.stemMesh=new PinStemMesh(t.stemNormal,t.stemEnabled,a,this.pinHeadMesh,r),this.add(this.stemMesh),this.updateMeshPosition(t),this.opacityAnimation=new ne.z(1)}dispose(){this.remove(this.pinHeadMesh),this.pinHeadMesh.material.dispose(),this.pinHeadMesh.dispose(),this.remove(this.stemMesh),this.stemMesh.dispose()}static disposeAll(){PinMeshGroup.pinHeadGeometry.dispose()}updateFromPin(e,i,t,n){this.position.copy(e.anchorPosition),this.pinHeadMesh.updatePosition(e),this.stemVector.copy(e.stemNormal).setLength(e.stemLength),this.stemEnabled=e.stemEnabled,this.stemMesh.updatePosition(e),this.stemMesh.visible=e.stemEnabled,i!==this.pinColor&&(this.pinColor=i,this.setColorVariant(this.currentColorVariant));const s=this.pinHeadMeshMaterial.uniforms;s.bg.value===t&&s.mask.value===n||(s.bg.value=t,s.mask.value=n,this.pinHeadMeshMaterial.uniformsNeedUpdate=!0)}setColorVariant(e){const i=te(this.pinColor,e);this.pinHeadMeshMaterial.uniforms.color.value.copy(i),this.currentColorVariant=e}setOpacity(e){this.baseOpacity=e,this.updateOpacity()}fadeOpacity(e){e>0&&(this.visible=!0),this.opacityAnimation.modifyAnimation(this.opacityAnimation.value,e,300).onComplete((()=>{e<=0&&(this.visible=!1)}))}setVisibility(e,i){this.visible=e,this.pinHeadMesh.visible=e,this.stemMesh.visible=e&&i}setStemEnabled(e){this.stemMesh.visible=this.visible&&e}updateMeshPosition(e){this.position.copy(e.anchorPosition),this.pinHeadMesh.updatePosition(e),this.stemMesh.updatePosition(e)}update(e,i,t,n){this.pinHeadMesh.update(i,t,n);const s=this.opacityAnimation.active;this.opacityAnimation.tick(e),s&&this.updateOpacity()}setRenderOverrides(e,i){this.pinHeadMesh.material=e?new ie.m0(e,!1):this.pinHeadMeshMaterial,i?this.pinHeadMesh.geomScale.copy(i):this.pinHeadMesh.geomScale.set(1,1,1),this.setOpacity(this.pinHeadMeshMaterial.opacity)}updateOpacity(){const e=this.opacityAnimation.value*this.baseOpacity;if(this.pinHeadMeshMaterial.opacity=e,this.pinHeadMeshMaterial.uniforms.alpha.value=e,this.pinHeadMesh.material!==this.pinHeadMeshMaterial){this.pinHeadMesh.material.opacity=e;const i=this.pinHeadMesh.material;i&&i.uniforms&&i.uniforms.alpha&&(i.uniforms.alpha.value=e)}this.stemMesh.pinStemMaterial.uniforms.alpha.value=e}}class NonInstancedPinRenderer extends PinRenderer{constructor(e,i,t,n,s,a){super(e,n,s,a),this.camera=i,this.canvasData=t,this.idToMesh=new Map}dispose(){super.dispose(),this.removePinsByPredicate((()=>!0)),PinMeshGroup.disposeAll()}activate(e){this.bindings.length>0||(super.activate(e),this.bindings.push(this.input.registerPriorityHandler(B.R,U.$,((i,t)=>{const n=t.parent;return e.broadcast(new Z.F7(n.pinId,n.pinType)),!0}))),(0,o.Jm)()||(this.bindings.push(this.input.registerMeshHandler(Q.z,E.s.isType(U.$),((i,t)=>{const n=t.parent;e.broadcast(new Z.tP(n.pinId,!0,n.pinType)),e.commandBinder.issueCommand(new S.u(T.C.FINGER)),e.commandBinder.issueCommand(new q.y(!0))}))),this.bindings.push(this.input.registerMeshHandler(Q.A,E.s.isType(U.$),((i,t)=>{const n=t.parent;e.broadcast(new Z.tP(n.pinId,!1,n.pinType)),e.commandBinder.issueCommand(new S.u(null)),e.commandBinder.issueCommand(new q.y(!1))})))))}render(e){const i=this.getViewportScale(this.canvasData);this.idToMesh.forEach((t=>{t.update(e,this.camera,i,this.canvasData)})),super.render(e)}updatePin(e,i,t,n,s,a){var r,o;super.updatePin(e,i,t,n,s,a);const d=this.getColor(t.color);let h=this.idToMesh.get(e);h||(h=new PinMeshGroup(e,i,t,d,this.layer,this.canvasData,n,s),this.idToMesh.set(e,h),this.input.registerMesh(h.pinHeadMesh,!1)),void 0!==a&&(h.visible=a),h.updateFromPin(t,d,n,s);const c=t.floorId;h.parent&&(null===(r=h.parent)||void 0===r?void 0:r.userData.floorId)===c||(h.parent&&(null===(o=h.parent)||void 0===o||o.remove(h)),this.getFloorContainer(c).userData.typeContainers[i].add(h))}removePin(e){var i;super.removePin(e);const t=this.idToMesh.get(e);t&&(this.idToMesh.delete(e),null===(i=t.parent)||void 0===i||i.remove(t),this.input.unregisterMesh(t.pinHeadMesh),t.dispose())}removePinsByPredicate(e){this.idToMesh.forEach(((i,t)=>{e(i.pinType)&&this.removePin(t)}))}setPinVisible(e,i){const t=this.idToMesh.get(e);t&&(t.visible=i)}setPinColorVariant(e,i){const t=this.idToMesh.get(e);t&&t.setColorVariant(i)}setPinColorVariants(e,i){this.idToMesh.forEach((t=>{t.pinId!==i&&t.setColorVariant(e)}))}setPinColorVariantByType(e,i,t){this.idToMesh.forEach((n=>{n.pinType===e&&n.pinId!==t&&n.setColorVariant(i)}))}setPinOpacity(e,i){const t=this.idToMesh.get(e);t&&t.setOpacity(i)}fadePinOpacity(e,i){const t=this.idToMesh.get(e);t&&t.fadeOpacity(i)}setPinOpacityByType(e,i,t){this.idToMesh.forEach((n=>{n.pinType===e&&n.pinId!==t&&n.setOpacity(i)}))}fadePinOpacityByType(e,i,t=[]){this.idToMesh.forEach((n=>{n.pinType!==e||t.includes(n.pinId)||n.fadeOpacity(i)}))}setPinRenderOverrides(e,i,t){super.setPinRenderOverrides(e,i,t);const n=this.idToMesh.get(e);n&&n.setRenderOverrides(i,t)}pinHeadTransform(e){const i=this.idToMesh.get(e);return i?i.pinHeadMesh.matrixWorld:new n.Matrix4}}var se=t(49487),ae=t(27408),re=t(68524),oe=t(12216),de=t(61709);const he=new ie.uW,ce=new x.Z("InstancedPinHeads");class InstancedPinLines extends n.InstancedMesh{constructor(e){const i=new n.BufferGeometry,t=new Float32Array(6);t[0]=t[1]=t[2]=0,t[3]=1,t[4]=1,t[5]=1,i.setAttribute("position",new n.BufferAttribute(t,3));const s=new Float32Array(3*e),a=new n.InstancedBufferAttribute(s,3);i.setAttribute("stemVector",a);const r=new Float32Array(e),o=new n.InstancedBufferAttribute(r,1);i.setAttribute("instanceAlpha",o);const d=[],h=[];for(let t=0;t<4;t++){const s=new Float32Array(4*e),a=new n.InstancedBufferAttribute(s,4);i.setAttribute(`pinHeadMatrixCol${t}`,a),d.push(s),h.push(a)}super(i,he,e),this.maxCount=e,this.stemVectorArray=s,this.stemVectorAttrib=a,this.pinHeadMatrixArray=d,this.pinHeadMatrixAttrib=h,this.opacityArray=r,this.opacityAttrib=o,this.renderOrder=L.z.lines,this.posMatrix=new n.Matrix4,this.isLine=!0,this.isMesh=!1}update(e,i){let t=0;for(const i of e){if(!i.visible||!i.stemEnabled||i.stemLength<.001)continue;if(t>=this.maxCount){ce.error("Instance count is too small!");continue}this.posMatrix.setPosition(i.anchorPosition),this.setMatrixAt(t,this.posMatrix),this.opacityArray[t]=i.opacity*i.opacityAnimation.value;const e=3*t;i.pinHeadObjPosition.toArray(this.stemVectorArray,e);let n=0;for(let e=0;e<4;e++)for(let s=0;s<4;s++)this.pinHeadMatrixArray[e][s+4*t]=i.pinHeadMatrix.elements[n++];t++}this.count=t,this.visible=this.count>0,this.instanceMatrix.needsUpdate=!0,this.stemVectorAttrib.needsUpdate=!0;for(const e of this.pinHeadMatrixAttrib)e.needsUpdate=!0;this.opacityAttrib.needsUpdate=!0,he.uniforms.resolution.value.set(i.width,i.height),he.uniformsNeedUpdate=!0}}const le=new x.Z("InstancedPinRenderer");class InstancedPinRenderer extends PinRenderer{constructor(e,i,t,s,a,r){super(e,s,a,r),this.camera=i,this.canvasData=t,this.pins=new Map,this.idToPin=new Map,this.keyToRenderObjs=new Map,this.updatePinHeadMatrix=(()=>{const e=new n.Vector3,i=new n.Vector3,t=new n.Vector3,s=new n.Vector3,a=new n.Vector3,r=new n.Vector3,o=new n.Vector3;return n=>{const d=z.Z.pinHeadMesh.scale,h=this.getViewportScale(this.canvasData),c=1+d.responsiveness/100*(h-1);this.camera.getWorldPosition(r);const l=this.camera.quaternion,p=this.canvasData;for(const h of n){o.copy(h.pinHeadObjPosition).add(h.anchorPosition);const n=r.distanceTo(o),u=d.maxSize-(d.maxSize-d.minSize)*(0,se.C)(n,d.nearBound,d.farBound);i.copy(o).project(this.camera),t.set(p.width/2,p.height/2,1).multiply(i),s.set(u/2,0,0).add(t),a.set(2/p.width,2/p.height,1).multiply(s);const m=a.unproject(this.camera).distanceTo(o)*c,P=(0,ae.uZ)(m,re.Z.epsilon,m),g=h.geomScale||oe.f.UNIT;e.set(P*g.x,P*g.y,P*g.z),h.pinHeadMatrix.compose(o,l,e)}}})()}dispose(){super.dispose()}activate(e){this.bindings.length>0||(super.activate(e),this.bindings.push(this.input.registerPriorityHandler(B.R,de.z,((i,t,n)=>{if(!n||void 0===n.instanceId)return!0;const s=t.renderedPins[n.instanceId];return e.broadcast(new Z.F7(s.id,s.pinType)),!0}))),(0,o.Jm)()||(this.bindings.push(this.input.registerMeshHandler(Q.z,E.s.isType(de.z),((i,t,n)=>{if(!n||void 0===n.instanceId)return;const s=t.renderedPins[n.instanceId];this.lastHoverId=s.id,this.lastHoverType=s.pinType,e.broadcast(new Z.tP(s.id,!0,s.pinType)),e.commandBinder.issueCommand(new S.u(T.C.FINGER)),e.commandBinder.issueCommand(new q.y(!0))}))),this.bindings.push(this.input.registerMeshHandler(Q.A,E.s.isType(de.z),(()=>{e.broadcast(new Z.tP(this.lastHoverId,!1,this.lastHoverType)),e.commandBinder.issueCommand(new S.u(null)),e.commandBinder.issueCommand(new q.y(!1))})))))}render(e){for(const i of this.pins.values()){const t=Array.from(i.values());if(0===t.length)continue;const n=this.keyFromPin(t[0]),s=this.keyToRenderObjs.get(n);if(!s){le.error("Expecting renderObjs for this key.",this.keyToRenderObjs,this.keyFromPin(t[0]));continue}let{lines:a,pinHeads:r}=s;if(t.forEach((i=>i.opacityAnimation.tick(e))),this.updatePinHeadMatrix(t),a.maxCount<t.length){const e=a.parent;if(!e){le.error("Expecting a parent.");continue}e.remove(a),a.dispose(),e.remove(r),this.input.unregisterMesh(r);const{backgroundTexture:i,maskTexture:n,overrideTexture:o}=t[0];r.dispose(),Object.assign(s,this.createInstances(e,s.id,t.length+16,i,n,o)),a=s.lines,r=s.pinHeads}a.update(t,this.canvasData),r.update(t)}super.render(e)}updatePin(e,i,t,s,a,r){var o;super.updatePin(e,i,t,s,a,r);let d=this.idToPin.get(e);const h=t.floorId,c=this.getColor(t.color).baseColor,l=`${h}_${i}_${(null===(o=null==d?void 0:d.overrideTexture)||void 0===o?void 0:o.uuid)||s.uuid}`;if(!d){d=Object.assign(Object.assign({id:e},t),{visible:!0,opacity:1,pinType:i,opacityAnimation:new ne.z(1),backgroundTexture:s,maskTexture:a,pinHeadMatrix:new n.Matrix4,pinHeadObjPosition:new n.Vector3,pinColor:c,colorVariant:F.K_.DEFAULT,overrideTexture:null,geomScale:null}),this.idToPin.set(e,d);let r=this.pins.get(l);r||(r=new Map,this.pins.set(l,r)),r.set(e,d),this.createRenderObjsForPin(d)}const p=this.keyFromPin(d);Object.assign(d,t,{pinType:i,textureId:s.uuid}),this.changePinHeadGroupIfNeeded(p,l,d),d.pinHeadObjPosition.copy(d.stemNormal).setLength(d.stemLength),d.pinColor=te(this.getColor(d.color),d.colorVariant),void 0!==r&&this.setPinVisible(e,r)}removePin(e){super.removePin(e);const i=this.idToPin.get(e);if(!i)return;this.idToPin.delete(e);const t=this.keyFromPin(i),n=this.pins.get(t);n&&(n.delete(e),this.cleanupRenderObjIfNeeded(t))}removePinsByPredicate(e){this.idToPin.forEach(((i,t)=>{e(i.pinType)&&this.removePin(t)}))}setPinVisible(e,i){const t=this.idToPin.get(e);t?t.visible=i:le.error("setPinVisible on a pin that doesn't exist.",e)}setPinColorVariant(e,i){const t=this.idToPin.get(e);t?(t.colorVariant=i,t.pinColor=te(this.getColor(t.color),i)):le.error("setPinColorVariant on a pin that doesn't exist.")}setPinColorVariants(e,i){this.idToPin.forEach(((t,n)=>{n!==i&&this.setPinColorVariant(n,e)}))}setPinColorVariantByType(e,i,t){this.idToPin.forEach(((n,s)=>{n.pinType===e&&s!==t&&this.setPinColorVariant(s,i)}))}setPinOpacity(e,i){const t=this.idToPin.get(e);t?t.opacity=i:le.error("setPinOpacity on a pin that doesn't exist.")}fadePinOpacity(e,i){const t=this.idToPin.get(e);t?(i>0&&this.setPinVisible(e,!0),t.opacityAnimation.modifyAnimation(t.opacityAnimation.value,i,300).onComplete((()=>{i<=0&&this.setPinVisible(e,!1)}))):le.error("setPinVisible on a pin that doesn't exist.",e)}setPinOpacityByType(e,i,t){this.idToPin.forEach(((n,s)=>{n.pinType===e&&s!==t&&this.setPinOpacity(s,i)}))}fadePinOpacityByType(e,i,t=[]){this.idToPin.forEach(((n,s)=>{n.pinType!==e||t.includes(s)||this.fadePinOpacity(s,i)}))}setPinRenderOverrides(e,i,t){super.setPinRenderOverrides(e,i,t);const n=this.idToPin.get(e);if(!n)return void le.error("setPinRenderOverrides on a pin that doesn't exist.");const s=this.keyFromPin(n);if(!this.keyToRenderObjs.get(s))return void le.error("Expecting renderObjs while setting override material");n.overrideTexture=i,n.geomScale=t;const a=this.keyFromPin(n);this.changePinHeadGroupIfNeeded(s,a,n)}pinHeadTransform(e){const i=this.idToPin.get(e);return i?i.pinHeadMatrix:(le.error("pinHeadTransform on a pin that doesn't exist."),new n.Matrix4)}keyFromPin(e){return`${e.floorId}_${e.pinType}_${e.overrideTexture?e.overrideTexture.uuid:e.backgroundTexture.uuid}`}createRenderObjsForPin(e){const{backgroundTexture:i,maskTexture:t,overrideTexture:n}=e,s=this.keyFromPin(e);if(this.keyToRenderObjs.get(s))return;const a=this.getFloorContainer(e.floorId).userData.typeContainers[e.pinType];a.userData||(a.userData={});const r=e.overrideTexture?e.overrideTexture.uuid:e.backgroundTexture.uuid;if(!a.userData[r]){const e=this.createInstances(a,r,16,i,t,n);a.userData[r]=e,this.keyToRenderObjs.set(s,e)}}createInstances(e,i,t,n,s,a){const r=new InstancedPinLines(t);r.layers.mask=this.layer.mask,e.add(r);const o=new de.z(t,a||n,a?null:s,!a);return o.layers.mask=this.layer.mask,e.add(o),this.input.registerMesh(o,!1),{lines:r,pinHeads:o,id:i}}changePinHeadGroupIfNeeded(e,i,t){if(e!==i){let n=this.pins.get(i);n||(n=new Map,this.pins.set(i,n)),n.set(t.id,t),this.createRenderObjsForPin(t);const s=this.pins.get(e);s&&(null==s||s.delete(t.id),this.cleanupRenderObjIfNeeded(e))}}cleanupRenderObjIfNeeded(e){const i=this.pins.get(e),t=this.keyToRenderObjs.get(e);if(i&&0===i.size&&t){const i=t.lines.parent;if(this.input.unregisterMesh(t.pinHeads),this.pins.delete(e),this.keyToRenderObjs.delete(e),!i)return void le.error("Expecting pinTypeObj!");i.userData[t.id]=void 0,i.remove(t.lines),i.remove(t.pinHeads)}}}class PinsModule extends s.Y{constructor(){super(...arguments),this.name="pins",this.editActivated=!1,this.editBindings=[],this.touchDevice=(0,o.Jm)(),this.worldPosition=new n.Vector3,this.visibilityChanged=()=>{const e=!this.in360View(),i=!this.interactionmodeData.isVR();this.pinRenderer.container.visible=e&&i;const{floorsViewData:t}=this,n=this.viewmode===P.Ey.Dollhouse||this.viewmode===P.Ey.Floorplan,s=t.transition.progress.active?()=>!0:t.isHidden;this.pinRenderer.setFloorsHidden(n?s:()=>!1)},this.viewmodeChanged=e=>{this.viewmode=e.toMode,this.visibilityChanged()},this.onEnablePinEditing=async e=>{e.enabled?this.enableEditing():this.disableEditing()},this.updateCurrentPin=()=>{const{pinEditorState:e,selectedPin:i,focusedPin:t}=this.viewData;if(e!==F.V8.CREATING){const e=t||i;if(this.pinEditor.updateAnchorMesh(),e){const{id:i,pinType:t,backgroundTexture:n,maskTexture:s}=e;this.pinRenderer.updatePin(i,t,e,n,s),this.pinRenderer.setPinColorVariant(i,F.K_.HIGHLIGHTED),this.pinRenderer.setPinColorVariants(F.K_.DEFAULT,i)}else this.pinRenderer.setPinColorVariants(F.K_.DEFAULT)}},this.onUpdatePin=async e=>{const{id:i,pinType:t,properties:n}=e,s=this.viewData.getPin(i);if(s&&s.pinType===t){const{selectedPin:e,focusedPin:t}=this.viewData,a=Object.assign(Object.assign({},s),n);this.viewData.updatePin(a),this.pinRenderer.updatePin(a.id,a.pinType,a,a.backgroundTexture,a.maskTexture),(null==e?void 0:e.id)===i&&(this.saveScreenPosition(a),this.viewData.updateSelectedPin(a)),(null==t?void 0:t.id)===i&&this.saveScreenPosition(a)}else this.log.debug(`Cannot update non-existent ${t} pin`)},this.onUpdatePinViews=async e=>{const{pinViews:i}=e,{selectedPin:t}=this.viewData;i.forEach((e=>{this.viewData.updatePin(e),this.pinRenderer.updatePin(e.id,e.pinType,e,e.backgroundTexture,e.maskTexture,e.visible),(null==t?void 0:t.id)===e.id&&this.viewData.updateSelectedPin(e),void 0!==e.opacity&&this.pinRenderer.setPinOpacity(e.id,e.opacity)}))},this.onChangePinVisibility=async e=>{const{id:i,pinType:t,visible:n}=e,s=this.viewData.getPin(i);if(s&&s.pinType===t){this.pinRenderer.setPinVisible(i,n);const{selectedPin:e,focusedPin:t}=this.viewData;n||(null==e?void 0:e.id)!==i||this.changeSelectedPin(null),n||(null==t?void 0:t.id)!==i||this.viewData.setFocusedPin(null)}else this.log.debug(`Cannot change visibility of non-existent ${t} pin`)},this.onChangePinVisibilityByType=async e=>{const{pinType:i,visible:t}=e;this.pinRenderer.setPinTypeVisible(i,t)},this.onChangePinOpacity=async e=>{const{id:i,pinType:t,opacity:n}=e,s=this.viewData.getPin(i);s&&s.pinType===t?this.pinRenderer.setPinOpacity(i,n):this.log.debug(`Cannot change opacity of non-existent ${t} pin`)},this.onChangePinOpacityByType=async e=>{const{pinType:i,opacity:t,skipIds:n}=e;this.pinRenderer.fadePinOpacityByType(i,t,n)},this.onUnselectPin=async e=>{const{pinType:i,id:t}=e,{selectedPin:n}=this.viewData;(null==n?void 0:n.pinType)===i&&(null==n?void 0:n.id)===t&&this.changeSelectedPin(null)},this.onStartPinCreation=async e=>{const{id:i,pin:t,pinType:n,backgroundTexture:s,maskTexture:a}=e,r=this.viewData,o=Object.assign(Object.assign({id:i,pinType:n},t),{backgroundTexture:s,maskTexture:a});r.setEditablePin(!0),r.setPinEditorState(F.V8.CREATING),this.changeSelectedPin(o),this.pinEditor.startPinCreation()},this.saveScreenPosition=(()=>{const e=new n.Vector3;return i=>{const t=this.viewData;e.copy(i.stemNormal).setLength(i.stemLength),this.worldPosition.copy(i.anchorPosition).add(e);const n=(0,r.q9)(this.cameraData,this.worldPosition);t.setScreenPosition(n.screenPosition)}})(),this.onCameraUpdate=()=>{const{creatingNewPin:e,focusedPin:i,selectedPin:t}=this.viewData;!e&&i?this.saveScreenPosition(i):t&&this.saveScreenPosition(t)},this.handleSweepChange=()=>this.handleSweepAndViewModeChange(),this.handleViewModeChange=()=>this.handleSweepAndViewModeChange(),this.cancelPinCreation=()=>{const{creatingNewPin:e,selectedPin:i}=this.viewData;e&&i&&(this.engine.broadcast(new Z.hu(i.id,i.pinType)),this.removePin(i.id,i.pinType),this.resetEditingState())},this.resetEditingState=()=>{const e=this.viewData;e.setPinEditorState(F.V8.IDLE),e.setEditablePin(!1),e.setCanPlace(!0),e.setCanAdd(!this.in360View())},this.onPinPlacementCancelled=()=>{this.cancelPinCreation()},this.onCancelNewPin=async e=>{const{pinType:i,id:t}=e;this.removePin(t,i),this.resetEditingState()},this.handleRemovingPin=async e=>{const{pinType:i,id:t}=e;this.removePin(t,i)},this.handleRemovingPinsByType=async e=>{const{pinType:i}=e;if(i===F.Er.MATTERTAG&&!this.tagsEnabled)return;this.viewData.removePinsByType(i),this.pinRenderer.removePinsByType(i);const{selectedPin:t,focusedPin:n}=this.viewData;(null==t?void 0:t.pinType)===i&&this.changeSelectedPin(null),(null==n?void 0:n.pinType)===i&&this.viewData.setFocusedPin(null)},this.onPinClicked=e=>{const{pinType:i,id:t}=e;if(i===F.Er.MATTERTAG&&!this.tagsEnabled)return;const{selectedPin:n,creatingNewPin:s}=this.viewData,a=t===(null==n?void 0:n.id)&&i===(null==n?void 0:n.pinType);if(n&&a){if(s)return;this.changeSelectedPin(null)}else if(s)this.cancelPinCreation();else{t===(null==n?void 0:n.id)&&i===(null==n?void 0:n.pinType)||this.engine.broadcast(new Z.Q4(t,i))}},this.onHoverChanged=e=>{const{pinType:i,id:t,hovering:n}=e;if(i===F.Er.MATTERTAG&&!this.tagsEnabled)return;const{creatingNewPin:s,focusedPin:a,selectedPin:r}=this.viewData;if(!s)if(n){if(r&&r.id===t&&r.pinType===i)return;const e=this.viewData.getPin(t);if(!e)return void this.log.debug("Cannot find pin to focus");this.viewData.setFocusedPin(e),this.saveScreenPosition(e),this.pinRenderer.setPinColorVariantByType(i,F.K_.DEFAULT,null==a?void 0:a.id),this.pinRenderer.setPinColorVariant(t,F.K_.HIGHLIGHTED)}else a&&(this.pinRenderer.setPinColorVariant(a.id,F.K_.DEFAULT),this.viewData.setFocusedPin(null))},this.onSelectPin=async e=>{const{id:i,pinType:t,editable:n}=e,s=this.viewData,{selectedPin:a,isPinEditable:r}=s;if(s.setPinEditorState(F.V8.IDLE),i===(null==a?void 0:a.id))return void(n===r?this.log.debug("Pin is already selected"):s.setEditablePin(n));const o=this.viewData.getPin(i);o&&o.pinType===t?(s.setEditablePin(n),s.setFocusedPin(null),this.changeSelectedPin(o)):this.log.debug(`Cannot select ${t} pin`)},this.clickOffPin=async()=>{this.viewData.creatingNewPin||this.changeSelectedPin(null)},this.movePin=async e=>{const{selectedPin:i,isPinEditable:t}=this.viewData;t&&(i&&i.id===e.id?(this.viewData.updateSelectedPin(e.pos),this.engine.broadcast(new Z.bV(i.id,i.pinType,e.pos))):this.log.debug("Cannot move the pin, not open for edit"))},this.placePin=async e=>{const{selectedPin:i,isPinEditable:t,canPlace:n}=this.viewData;t&&(i&&n?(this.viewData.setPinEditorState(F.V8.PLACED),this.engine.broadcast(new Z.b0(i.id,i.pinType,i))):(this.log.debug("Cannot place pin because there is no open pin"),this.cancelPinCreation()))}}async init(e,i){this.engine=i,this.tagsEnabled=e.newTagsEnabled;const[t,n,s,r,o]=await Promise.all([i.getModuleBySymbol(a.y.INPUT),i.getModuleBySymbol(a.y.WEBGL_RENDERER),i.market.waitForData(h.W),i.market.waitForData(d.pu),i.getModuleBySymbol(a.y.RAYCASTER)]);this.input=t;const P=i.claimRenderLayer(this.name);this.pinRenderer=n.supportsInstancing()?new InstancedPinRenderer(t,n.getCamera(),s,P,i.commandBinder,o):new NonInstancedPinRenderer(t,n.getCamera(),s,P,i.commandBinder,o),n.getScene().add(this.pinRenderer.container),i.addComponent(this,this.pinRenderer),[this.floorsViewData,this.viewmodeData,this.interactionmodeData,this.sweepData,this.cameraData]=await Promise.all([i.market.waitForData(c.c),i.market.waitForData(m.O),i.market.waitForData(l.Z),i.market.waitForData(u.Z),i.market.waitForData(p.M_)]),this.viewData=new w.B,this.pinEditor=new PinEditor(this.viewData,this.engine,this.input,this.pinRenderer),this.floorsViewData.iterate((e=>this.pinRenderer.getFloorContainer(e.id))),this.viewmode=this.viewmodeData.currentMode,this.bindings.push(i.commandBinder.addBinding(_.Ki,this.onEnablePinEditing),i.commandBinder.addBinding(_.Ar,this.onSelectPin),i.commandBinder.addBinding(_.RH,this.onUnselectPin),i.commandBinder.addBinding(_.yR,this.clickOffPin),i.commandBinder.addBinding(_.tE,this.onUpdatePin),i.commandBinder.addBinding(_.mE,this.onUpdatePinViews),i.commandBinder.addBinding(_.ik,this.onChangePinVisibility),i.commandBinder.addBinding(_.qN,this.onChangePinVisibilityByType),i.commandBinder.addBinding(_._Y,this.onChangePinOpacity),i.commandBinder.addBinding(_.kb,this.onChangePinOpacityByType),this.interactionmodeData.onChanged(this.visibilityChanged),this.floorsViewData.onChanged(this.visibilityChanged),this.viewmodeData.makeModeChangeSubscription(this.visibilityChanged),i.subscribe(g.Z,this.visibilityChanged),i.subscribe(y.a,this.viewmodeChanged),i.subscribe(v.Z,this.viewmodeChanged),i.subscribe(Z.F7,this.onPinClicked),this.viewData.onPinEditorStateChanged(this.updateCurrentPin),this.viewData.onSelectedPinChanged(this.updateCurrentPin),this.viewData.onFocusedPinChanged(this.updateCurrentPin),this.viewData.onPinEditableChanged(this.updateCurrentPin),this.cameraData.onChanged(this.onCameraUpdate)),this.touchDevice||this.bindings.push(i.subscribe(Z.tP,this.onHoverChanged));let C=r.application;this.bindings.push(r.onPropertyChanged("application",(e=>{e!==C&&(this.visibilityChanged(),this.viewData.creatingNewPin?this.cancelPinCreation():(this.changeSelectedPin(null),this.viewData.setFocusedPin(null),this.resetEditingState()),C=e)}))),this.visibilityChanged(),i.market.register(this,w.B,this.viewData)}dispose(e){this.disableEditing(),this.viewData.setPinEditorState(F.V8.IDLE),this.pinEditor.dispose(),this.pinRenderer.dispose(),this.bindings.forEach((e=>{e.cancel()})),this.bindings=[],this.editBindings=[],super.dispose(e)}onUpdate(){this.editActivated&&this.pinEditor.update()}in360View(){const e=this.sweepData.currentSweep?this.sweepData.currentSweep:"";return this.viewmodeData.isInside()&&this.sweepData.isSweepUnaligned(e)}enableEditing(){if(!this.editActivated){if(this.editActivated=!0,this.pinEditor.toggleEditing(!0),0===this.editBindings.length){const e=this.engine,i=e.commandBinder;this.editBindings.push(i.addBinding(_.fM,this.onStartPinCreation),i.addBinding(_.OL,this.handleRemovingPin),i.addBinding(_.zM,this.handleRemovingPinsByType),i.addBinding(_.ip,this.placePin),i.addBinding(_.tT,this.onCancelNewPin),i.addBinding(_.I$,this.movePin),this.sweepData.makeSweepChangeSubscription(this.handleSweepChange),e.subscribe(v.Z,this.handleViewModeChange),e.subscribe(Z.pe,this.onPinPlacementCancelled))}else this.editBindings.forEach((e=>{e.renew()}));this.handleSweepAndViewModeChange()}}disableEditing(){this.editActivated&&(this.editActivated=!1,this.pinEditor.toggleEditing(!1),this.resetEditingState(),this.editBindings.forEach((e=>{e.cancel()})))}changeSelectedPin(e){const{selectedPin:i}=this.viewData;(null==e?void 0:e.id)!==(null==i?void 0:i.id)?(i&&(this.engine.broadcast(new Z.WM(i.id,i.pinType)),this.pinRenderer.hideSelectedMesh()),this.viewData.setSelectedPin(e),e?(this.saveScreenPosition(e),this.pinRenderer.showSelectedMesh(e.pinType,e.id)):this.viewData.setScreenPosition(null)):this.log.debug("Pin selection did not change")}handleSweepAndViewModeChange(){const e=this.viewData,i=!this.in360View();e.creatingNewPin&&!i?(this.cancelPinCreation(),this.resetEditingState()):e.setCanAdd(i)}removePin(e,i){if(i===F.Er.MATTERTAG&&!this.tagsEnabled)return;this.viewData.removePin(e),this.pinRenderer.removePin(e);const{selectedPin:t,focusedPin:n}=this.viewData;(null==t?void 0:t.id)===e&&(null==t?void 0:t.pinType)===i&&this.changeSelectedPin(null),(null==n?void 0:n.id)===e&&(null==n?void 0:n.pinType)===i&&this.viewData.setFocusedPin(null)}}const pe=PinsModule},79386:(e,i,t)=>{"use strict";t.d(i,{l:()=>n,Z:()=>s});const n=1,s=Object.freeze({anchor:{size:.1},stem:{length:.23,width:1,opacity:1,transparent:!0,color:"white",alphaTest:.05},pinHeadMesh:{scale:{nearBound:1.5,farBound:4.8,maxSize:80,minSize:40,baseViewportSize:800,responsiveness:100}}})},49487:(e,i,t)=>{"use strict";function n(e,i,t){return e<=i?0:e>=t?1:(e=(e-i)/(t-i))*e*(3-2*e)}t.d(i,{C:()=>n})},36888:e=>{e.exports="precision highp float;precision highp int;uniform mat4 viewMatrix;uniform vec3 cameraPosition;\n#ifdef INSTANCED\nvarying float alpha;varying vec3 color;\n#else\nuniform float alpha;uniform vec3 color;\n#endif\nuniform sampler2D bg;uniform sampler2D mask;varying vec2 vUv;void main(){vec4 bgColor=texture2D(bg,vUv);if(bgColor.a*alpha<0.1){discard;}vec4 maskColor=texture2D(mask,vUv);vec3 mappedColor=mix(color,maskColor.rgb,maskColor.a);gl_FragColor=vec4(mappedColor,bgColor.a*alpha);}"},34086:e=>{e.exports="precision highp float;precision highp int;uniform mat4 modelMatrix;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;uniform mat4 viewMatrix;uniform mat3 normalMatrix;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;varying vec2 vUv;\n#ifdef INSTANCED\nattribute mat4 instanceMatrix;attribute float instanceAlpha;attribute vec3 instanceColor;varying float alpha;varying vec3 color;\n#endif\nvoid main(){vUv=uv;\n#ifdef INSTANCED\nalpha=instanceAlpha;color=instanceColor;gl_Position=projectionMatrix*modelViewMatrix*instanceMatrix*vec4(position,1.);\n#else\ngl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n#endif\n}"},81713:e=>{e.exports="precision highp float;precision highp int;uniform mat4 viewMatrix;uniform vec3 cameraPosition;varying vec2 vUv;void main(){float dist=length(vUv);float alpha=(1.-smoothstep(0.95,1.,dist))*0.3;gl_FragColor=vec4(1.,1.,1.,alpha);}"},18144:e=>{e.exports="precision highp float;precision highp int;uniform mat4 modelMatrix;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;uniform mat4 viewMatrix;uniform mat3 normalMatrix;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;varying vec2 vUv;void main(){vUv=(uv*2.)-1.;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);gl_Position.z*=1.00001;}"},7532:e=>{e.exports="precision highp float;precision highp int;uniform mat4 viewMatrix;uniform vec3 cameraPosition;\n#ifdef INSTANCED\nvarying float alpha;\n#else\nuniform float alpha;\n#endif\nvoid main(){gl_FragColor=vec4(1.,1.,1.,alpha);}"},18934:e=>{e.exports="precision highp float;precision highp int;uniform mat4 modelMatrix;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;uniform mat4 viewMatrix;uniform mat3 normalMatrix;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;uniform vec2 resolution;\n#ifdef INSTANCED\nattribute mat4 instanceMatrix;attribute vec3 stemVector;attribute vec4 pinHeadMatrixCol0;attribute vec4 pinHeadMatrixCol1;attribute vec4 pinHeadMatrixCol2;attribute vec4 pinHeadMatrixCol3;attribute float instanceAlpha;varying float alpha;\n#else\nuniform mat4 pinHeadMatrix;\n#endif\n#define PI  3.1415926538\nvoid main(){\n#ifdef INSTANCED\nvec3 pos=position*stemVector;mat4 modelViewProjMatrix=projectionMatrix*modelViewMatrix*instanceMatrix;mat4 pinHeadMatrix=mat4(pinHeadMatrixCol0,pinHeadMatrixCol1,pinHeadMatrixCol2,pinHeadMatrixCol3);alpha=instanceAlpha;\n#else\nvec3 pos=position;mat4 modelViewProjMatrix=projectionMatrix*modelViewMatrix;\n#endif\nvec3 fromOrigin=(vec3(0.,0.,0.)-pos);if(length(fromOrigin)<1e-6){gl_Position=modelViewProjMatrix*vec4(pos,1.);}else{mat4 noteViewProj=projectionMatrix*viewMatrix*pinHeadMatrix;vec4 noteNDC=noteViewProj*vec4(0.,0.,0.,1.);noteNDC.xyz/=abs(noteNDC.w);vec4 discEdgeNDC=noteViewProj*vec4(0.5,0.,0.,1.);discEdgeNDC.xyz/=abs(discEdgeNDC.w);float noteSizeNDC=length(discEdgeNDC.xy-noteNDC.xy);vec4 anchorNDC=modelViewProjMatrix*vec4(0.,0.,0.,1.);anchorNDC.xyz/=abs(anchorNDC.w);vec4 vectorNDC=modelViewProjMatrix*vec4(pos,1.);vectorNDC.xyz/=abs(vectorNDC.w);vectorNDC-=anchorNDC;float lineLengthNDC=length(vectorNDC.xy);float vertDot=abs(dot(normalize(vectorNDC.xy),vec2(0,1)));float angle=acos(vertDot)/(PI/2.);float aspect=mix(resolution.x/resolution.y,1.,angle);vec2 vector2d=normalize(vectorNDC.xy)*max(lineLengthNDC-noteSizeNDC*aspect,0.);vectorNDC.xy=vector2d.xy;vectorNDC+=anchorNDC;gl_Position=vec4(vectorNDC.xyz,1.);}}"}}]);